import backtrader
import inspect

from ccxtbt.bt_ccxt__specifications import CASH_DIGITS
from ccxtbt.utils import legality_check_not_none_obj, round_to_nearest_decimal_points


class Enhanced_Trade(backtrader.Trade):
    def __init__(self, datafeed=None, tradeid=0, historyon=False, size=0.0, price=0.0, commission_amount=0.0):
        super().__init__(
            datafeed=datafeed, tradeid=tradeid, historyon=historyon, size=size, price=price, value=0.0,
            commission_amount=commission_amount)

        # Variables
        self.initial_margin = 0.0
        self.average_entry_price = 0.0

    def update(self, order, size, price, commission_amount, profit_and_loss_amount, commission_info):
        '''
        Updates the current trade. The logic does not check if the
        trade is reversed, which is not conceptually supported by the
        object.

        If an update sets the size attribute to 0, "closed" will be
        set to true

        Updates may be received twice for each order, once for the existing
        size which has been closed (sell undoing a buy) and a second time for
        the opening part (sell reversing a buy)

        Args:
            order: the order object which has (completely or partially)
                generated this update
            size (int): amount to update the order
                if size has the same sign as the current trade a
                position increase will happen
                if size has the opposite sign as current op size a
                reduction/close will happen

            price (float): always be positive to ensure consistency
            commission_amount (float): incurred commission_amount in the new size/price op
            profit_and_loss_amount (float): (unused) generated by the executed part
                         Not used because the trade has an independent profit_and_loss_amount
        '''
        if not size:
            return  # empty update, skip all other calculations

        dump = False
        # # TODO: Debug Use
        # dump = True

        legality_check_not_none_obj(commission_info, "commission_info")

        # Commission can only increase
        self.commission_amount += commission_amount

        # Update size and keep a reference for logic an calculations
        oldsize = self.size
        self.size += size  # size will carry the opposite sign if reducing

        # size could deviate from its original value due to floating point precision error. The
        #       following codes are to provide remedy for that situation.
        self.size = \
            round_to_nearest_decimal_points(
                self.size, commission_info.qty_digits, commission_info.qty_step)

        # Check if it has been currently opened
        self.justopened = bool(not oldsize and size)

        if self.justopened:
            self.baropen = len(self.datafeed)
            self.dtopen = 0.0 if order.p.simulated else self.datafeed.datetime[0]
            self.long = self.size > 0

        # Any size means the trade was opened
        self.isopen = bool(self.size)

        # Update current trade length
        self.barlen = len(self.datafeed) - self.baropen

        # record if the position was closed (set to null)
        self.isclosed = bool(oldsize and not self.size)

        # record last bar for the trade
        if self.isclosed:
            self.isopen = False
            self.barclose = len(self.datafeed)
            self.dtclose = self.datafeed.datetime[0]

            self.status = self.Closed
        elif self.isopen:
            self.status = self.Open

        initial_margin = commission_info.get_initial_margin(
            size, price, force=True)
        if abs(self.size) > abs(oldsize):
            # position increased (be it positive or negative)
            if abs(oldsize) == 0.0:
                self.price = price
            else:
                # update the average price
                self.price = (oldsize * self.price + size * price) / self.size
            profit_and_loss_amount = 0.0

            # price could deviate from its original value due to floating point precision error. The
            #       following codes are to provide remedy for that situation.
            self.price = \
                round_to_nearest_decimal_points(self.price, commission_info.price_digits,
                                                commission_info.tick_size)

            self.initial_margin += initial_margin
        else:  # abs(self.size) < abs(oldsize)
            # position reduced/closed
            profit_and_loss_amount = commission_info.profit_and_loss(
                -size, self.price, price)
            self.initial_margin -= initial_margin

        self.profit_and_loss_amount += profit_and_loss_amount
        self.pnlcomm = self.profit_and_loss_amount - self.commission_amount

        if dump:
            msg = "{} Line: {}: order id: {}".format(
                inspect.getframeinfo(inspect.currentframe()).function,
                inspect.getframeinfo(inspect.currentframe()).lineno,
                order.ref,
            )
            msg += ", PNL: {:.{}f}, Comm: {:.{}f}, PNLComm: {:.{}f}, IM: {:.{}f}".format(
                self.profit_and_loss_amount, CASH_DIGITS,
                commission_amount, CASH_DIGITS,
                self.pnlcomm, CASH_DIGITS,
                self.initial_margin, CASH_DIGITS,
            )
            print(msg)

        self.value = commission_info.get_value_size(self.size, self.price)

        # Update the history if needed
        if self.historyon:
            dt0 = self.datafeed.datetime[0] if not order.p.simulated else 0.0
            histentry = backtrader.TradeHistory(
                self.status, dt0, self.barlen,
                self.size, self.price, self.value,
                self.profit_and_loss_amount, self.pnlcomm, self.datafeed._tz)
            histentry.doupdate(order, size, price, commission_amount)
            self.history.append(histentry)

        # This calculation is required to address Back Broker or Exchange do not consider partially close
        #       position to update the position's Average Entry Price (AEP)
        effective_qty = 0.0
        effective_value = 0.0
        for history in self.history:
            history_size = history.event.size
            effective_qty += history_size
            effective_value += history.event.price * history_size
        self.average_entry_price = abs(
            effective_value / (effective_qty or 1.0))
        self.average_entry_price = \
            round_to_nearest_decimal_points(self.average_entry_price, commission_info.price_digits,
                                            commission_info.tick_size)
        pass
